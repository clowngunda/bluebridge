/*
标题：史丰收速算
史丰收速算法的革命性贡献是：从高位算起，预测进位。不需要九九表，彻底颠覆了传统手算!
速算的核心基础是：1位数乘以多位数的乘法。
其中，乘以7是最复杂的，就以它为例。
因为，1/7 是个循环小数：0.142857...，如果多位数超过 142857...，就要进1
同理，2/7, 3/7, ... 6/7 也都是类似的循环小数，多位数超过 n/7，就要进n
下面的程序模拟了史丰收速算法中乘以7的运算过程。
乘以 7 的个位规律是：偶数乘以2，奇数乘以2再加5，都只取个位。
乘以 7 的进位规律是：
满 142857... 进1,
满 285714... 进2,
满 428571... 进3,
满 571428... 进4,
满 714285... 进5,
满 857142... 进6
请分析程序流程，填写划线部分缺少的代码。
*/
//计算个位
int ge_wei(int a)
{
    if(a % 2 == 0)
        return (a * 2) % 10;
    else
        return (a * 2 + 5) % 10;
}

//计算进位
int jin_wei(char* p)
{
    char* level[] = {
        "142857",
        "285714",
        "428571",
        "571428",
        "714285",
        "857142"
    };

    char buf[7];
    buf[6] = '\0';
    strncpy(buf,p,6);

    int i;
    for(i=5; i>=0; i--){
        int r = strcmp(level[i], buf);
        if(r<0) return i+1;
        while(r==0){
            p += 6;
            strncpy(buf,p,6);
            r = strcmp(level[i], buf);
            if(r<0) return i+1;
            ______________________________;  //填空
        }
    }

    return 0;
}

//多位数乘以7
void f(char* s)
{
    int head = jin_wei(s);
    if(head > 0) printf("%d", head);

    char* p = s;
    while(*p){
        int a = (*p-'0');
        int x = (ge_wei(a) + jin_wei(p+1)) % 10;
        printf("%d",x);
        p++;
    }

    printf("\n");
}

int main()
{
    f("428571428571");
    f("34553834937543");
    return 0;
}
注意：通过浏览器提交答案。只填写缺少的内容，不要填写任何多余的内容（例如：说明性文字）


解题思路
首先，要把这段代码里面涉及到的几个字符串函数弄清楚，作用如下：
char *strncpy( char *to, const char *from, size_t count );
功能：将字符串from 中至多count个字符复制到字符串to中。如果字符串from 的长度小于count，其余部分用'\0'填补。返回处理完成的字符串。
char *strcpy( char *to, const char *from )
功能：复制字符串from 中的字符到字符串to，包括空值结束符。返回值为指针to。
int strcmp( const char *str1, const char *str2 );
功能：比较字符串str1 and str2, 返回值为str1 - str2的值。
然后，一步一步的读代码就可以了。
题目中给出的两个测试数据的运算结果分别为
241876844562801
241876844562801
我的答案
我的答案和参考答案有细微差别，但是分析一下其实是一样的，使用给出的测试数据也可以通过。
if(!*p) return i
参考答案
给出的参考答案似乎让人更容易理解，我想的太复杂了。
if(r>0) return i
测评方法
这是一个代码填空题，用考生提交的答案代替程序中的空，运行程序，比对结果。
测评中给出的数据是
f("1847255097268459");
f("1428571428571");
f("1428571428572");
f("4285714285714286");
结果输出为
12930785680879213
9999999999997
10000000000004
30000000000000002
